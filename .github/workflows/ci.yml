name: CI

on:
  workflow_dispatch:
  pull_request:
    branches: [master, main]

jobs:
  deploy:
    runs-on: self-hosted
    
    permissions:
      contents: write
      pull-requests: write
      checks: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Build with Nix
        run: |
          echo "Building test-app..."
          nix build .#test-app
          echo "Store path: $(readlink result)"
      
      - name: Deploy to production
        if: success()
        run: |
          # Use StateDirectory for consistent builds (writable by runner)
          BUILD_DIR="/var/lib/github-runner/test-app-runner/builds"
          echo "Using build directory: $BUILD_DIR"
          mkdir -p "$BUILD_DIR"
          
          # Get git commit before changing directory
          export GIT_COMMIT=$(git rev-parse --short HEAD)
          
          # Clean and sync to build directory
          echo "Syncing to build directory..."
          rm -rf "$BUILD_DIR"/*
          rm -rf "$BUILD_DIR"/.??* 2>/dev/null || true
          rsync -av --exclude='node_modules' --exclude='result' --exclude='.git' . "$BUILD_DIR"/
          cd "$BUILD_DIR"
          
          # Touch flake.nix to bust nix cache for upgrades
          touch flake.nix
          
          # Build and install from consistent location
          echo "Building and updating nix profile..."
          echo "Building version: $GIT_COMMIT"
          
          # Debug: Check current profile before changes
          echo "=== Current nix profile before update ==="
          echo "User: $(whoami)"
          echo "Profile path: $HOME/.nix-profile"
          nix profile list | grep test-app || echo "No test-app in profile"
          
          # Build the package
          echo "=== Building package ==="
          nix build .#test-app --print-out-paths
          STORE_PATH=$(readlink -f result)
          echo "Built store path: $STORE_PATH"
          
          # Try to upgrade or install
          echo "=== Attempting profile update ==="
          
          # Check if test-app exists and where it's from
          # Note: grep pattern must account for ANSI color codes in nix profile output
          if nix profile list | grep -E "test-app" > /dev/null; then
            CURRENT_FLAKE_URL=$(nix profile list | sed 's/\x1b\[[0-9;]*m//g' | grep -A3 "^Name:.*test-app" | grep "Original flake URL:" | sed 's/Original flake URL: *//' | xargs)
            echo "Current flake URL: '$CURRENT_FLAKE_URL'"
            echo "Expected flake URL: 'path:$BUILD_DIR'"
            
            if [[ "$CURRENT_FLAKE_URL" != "path:$BUILD_DIR" ]]; then
              echo "⚠️ Profile points to different location ($CURRENT_FLAKE_URL), removing and reinstalling from $BUILD_DIR"
              nix profile remove test-app || true
              nix profile install .#test-app
            else
              echo "test-app exists in profile from correct location, attempting upgrade..."
              nix profile upgrade test-app || {
                echo "⚠️ Upgrade failed, removing and reinstalling..."
                nix profile remove test-app
                nix profile install .#test-app
              }
            fi
          else
            echo "test-app not in profile, installing fresh..."
            nix profile install .#test-app
          fi
          
          # Debug: Check profile after changes
          echo "=== Nix profile after update ==="
          nix profile list | grep -A3 "^Name:.*test-app$" || echo "❌ No test-app in profile"
          
          # CRITICAL ASSERTION: Verify the profile actually updated
          echo "=== VERIFYING PROFILE UPDATE ==="
          # Strip ANSI color codes before parsing
          FINAL_FLAKE_URL=$(nix profile list | sed 's/\x1b\[[0-9;]*m//g' | grep -A3 "^Name:.*test-app" | grep "Original flake URL:" | sed 's/Original flake URL: *//' | xargs)
          FINAL_STORE_PATH=$(nix profile list | sed 's/\x1b\[[0-9;]*m//g' | grep -A4 "^Name:.*test-app" | grep "Store paths:" | sed 's/Store paths: *//' | xargs)
          
          echo "Final flake URL: '$FINAL_FLAKE_URL'"
          echo "Final store path: '$FINAL_STORE_PATH'"
          echo "Expected flake URL: 'path:$BUILD_DIR'"
          echo "Built store path: '$STORE_PATH'"
          
          # Fail if profile didn't update correctly
          if [[ "$FINAL_FLAKE_URL" != "path:$BUILD_DIR" ]]; then
            echo "❌ CRITICAL ERROR: Profile did not update to the correct location!"
            echo "   Expected: path:$BUILD_DIR"
            echo "   Got: $FINAL_FLAKE_URL"
            exit 1
          fi
          
          # Check that we have a store path (don't compare exact path due to impure builds)
          if [[ -z "$FINAL_STORE_PATH" ]]; then
            echo "❌ CRITICAL ERROR: No store path found in profile!"
            exit 1
          fi
          
          echo "✅ Profile successfully updated!"
          
          # Debug: Check what binary is actually being used
          echo "=== Which test-app is in PATH ==="
          which test-app || echo "test-app not in PATH"
          ls -la $(which test-app) 2>/dev/null || true
          
          # Debug: Check systemd service configuration
          echo "=== Systemd service configuration ==="
          systemctl cat test-app || true
          
          # Restart using polkit (already working)
          echo "Restarting service using polkit..."
          systemctl restart test-app
          
          echo "Checking service status..."
          systemctl status test-app --no-pager || true
          
          # Debug: Check what's actually running
          echo "=== Process info ==="
          ps aux | grep test-app | grep -v grep || true
          
          echo "Testing endpoint..."
          sleep 2
          EMOJI=$(curl -s http://localhost:3001 | grep -o "emoji.*</div>" | head -1)
          echo "Current emoji: $EMOJI"
          
          # Verify deployment succeeded
          if [[ -z "$EMOJI" ]]; then
            echo "Failed to fetch page!"
            exit 1
          fi
      
      - name: Auto-merge PR
        if: |
          success() && 
          github.event_name == 'pull_request' && 
          github.event.pull_request.user.login == github.repository_owner
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "All tests and deployment passed! Merging PR #${{ github.event.pull_request.number }}"
          gh pr merge ${{ github.event.pull_request.number }} \
            --repo ${{ github.repository }} \
            --squash \
            --delete-branch